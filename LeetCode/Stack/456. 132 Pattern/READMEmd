# [456. 132 Pattern](https://leetcode.com/problems/132-pattern/)

**Difficulty:** Medium

---

## Problem Statement

Given an array of `n` integers `nums`, a 132 pattern is a subsequence of three integers `nums[i]`, `nums[j]`, and `nums[k]` such that `i < j < k` and `nums[i] < nums[k] < nums[j]`.

Return `true` if there is a 132 pattern in `nums`, otherwise return `false`.

---

## Examples

### Example 1

**Input:**
```
nums = [1,2,3,4]
```
**Output:**
```
false
```
**Explanation:**  
There is no 132 pattern in the sequence.

---

### Example 2

**Input:**
```
nums = [3,1,4,2]
```
**Output:**
```
true
```
**Explanation:**  
There is a 132 pattern in the sequence: [1, 4, 2].

---

### Example 3

**Input:**
```
nums = [-1,3,2,0]
```
**Output:**
```
true
```
**Explanation:**  
There are several 132 patterns in the sequence.

---

## Constraints

- `n == nums.length`
- `1 <= n <= 2 * 10^5`
- `-10^9 <= nums[i] <= 10^9`

---

## Approach

- Traverse the array from right to left.
- Use a stack to keep track of possible `nums[j]` values.
- Maintain a variable `third` to store the maximum `nums[k]` found so far that could be part of a 132 pattern.
- For each `nums[i]`:
  - If `nums[i] < third`, a 132 pattern is found, return `true`.
  - While the stack is not empty and `nums[i] > stack.top()`, update `third` and pop from the stack.
  - Push `nums[i]` onto the stack.
- If no pattern is found, return `false`.

---

